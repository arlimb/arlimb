/*  <TCP server that handles incoming messages and passes them to other components of ARlimb.>
    Copyright (C) 2020  Christian Kaltschmidt <c.kaltschmidt@gmx.de>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18063
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections;
using System.Threading;
using System.Net.Sockets;
using System.Text;
using System.Net;
using System.Diagnostics;
using System.IO;


namespace AssemblyCSharp
{
    public delegate void EventIncomingMessage(TCPServer.ByteCast msg, bool manualControl = false);

    public class TCPServer
	{
        //event object that listeners have to be regiestered to
        public event EventIncomingMessage incomingMessage;

		private static int counter=0;
		private TcpListener tcpListener;
		private Thread listenThread;

		//Server property
		private int Port = 4;
		private IPAddress localAddr = IPAddress.Parse("127.0.0.1");
		private const int bufferSize = 512;

		//Byte array [Operation val1 val2 val3] used to code the movement
		public ByteCast MsgByte;
		public struct ByteCast{
			public byte Operation;
			public byte val1;
			public byte val2;
			public byte val3;
            public byte val4;
            public byte[] heatmap;
		}

		//Movements List
		//public enum HandMovement { Error, Rest, Close, Open, Extend, Flex, Pronation, Supination, Index, Pincer };
		public HandMovement.Movement movement;

		//Encoded message 
		public string Message {
			get;
			set;
		}

        //TCPServer instance
        private static TCPServer _instance = null;// new TCPServer();
		private static TCPServer Instance
		{
			get { return _instance; }
		}
        public static TCPServer getInstance(string ip, int port)
        {
            if (_instance  == null)
            {
                _instance = new TCPServer( ip, port);
            }

            return Instance;
        }
        //used to stop tcpListener
        private bool ShouldStop;

		private byte AckByte { get; set;}
		public bool WaitForAck { get; set;}

		//Start the server
		public TCPServer ()
		{
			Message = string.Empty;
			WaitForAck = true;
			this.tcpListener = new TcpListener (this.localAddr, this.Port);
			this.listenThread = new Thread (new ThreadStart (listenForClients));
			this.tcpListener.Start();
			this.listenThread.Start();
		}

        public TCPServer( string ip, int port)
        {
            Message = string.Empty;
            WaitForAck = true;
            this.tcpListener = new TcpListener(IPAddress.Parse(ip), port);
            this.listenThread = new Thread(new ThreadStart(listenForClients));
            this.tcpListener.Start();
            this.listenThread.Start();
        }

        /// <summary>
        /// Listens for clients.
        /// </summary>
        private void listenForClients ()
		{
			try
			{
				while (!ShouldStop){

					while (this.tcpListener.Pending() == false && !ShouldStop) { System.Threading.Thread.Sleep(1);}

					if (this.tcpListener.Pending()){
						// client has connected
						TcpClient client = this.tcpListener.AcceptTcpClient();
						
						// create a thread to handle communication 
						Thread clientThread = new Thread(new ParameterizedThreadStart(HandleClientComm));
						clientThread.Start(client);
					}
				}
				
			}
			catch (Exception e)
			{
				System.Diagnostics.Debug.WriteLine(e.ToString());
			}
		}

		/// <summary>
		/// Handles the client and get movement.
		/// </summary>
		/// <param name="client">Client.</param>
		void HandleClientComm (object client)
		{
			Message = string.Empty;
			
			TcpClient tcpClient = (TcpClient)client;
			NetworkStream clientStream = tcpClient.GetStream();
			
			byte[] message = new byte[bufferSize];
			int bytesRead;
			
			while (true) {
				bytesRead = 0;
				
				try {
					// recive message
					bytesRead = clientStream.Read (message, 0, bufferSize);
				} catch {
					// a socket error has occured
					break;
				}
				
				if (bytesRead == 0) {
					// the client has disconnected from the server
					break;
				}

				Message = DecodeMsg(message); //this variable is unnecessary. should be deleted!

                UnityEngine.Debug.LogWarning("Msg: "+ MsgByte.Operation + MsgByte.val1.ToString() + MsgByte.val2.ToString() + MsgByte.val3.ToString());

                //fires the message event
                if (incomingMessage != null)
                {
                    incomingMessage(MsgByte);
                }

				movement = GetMovement(MsgByte);
				//WaitForAck = false;
				while (WaitForAck) {System.Threading.Thread.Sleep(10);}
				WaitForAck = true;

				// send acknowledge byte
				clientStream.WriteByte(AckByte);

			}
		}

		/// <summary>
		/// Requests to stop the tcpListener.
		/// </summary>
		public void RequestStop()
		{
			ShouldStop = true;
		}

		/// <summary>
		/// Decodes the message "0901--" for Open the val2 and val3 are for simultaneous and propositional movments. Extract the heatmap
		/// </summary>
		/// <returns>Decoded message.</returns>
		/// <param name="msg">Byte array recieved from the client.</param>
		private String DecodeMsg(Byte[] msg)
		{
			byte[] subArray = new byte[197]; // 197 = 5 control bytes + 192 colors {0,...,63} bytes
			for (int i = 0; i < 197; i++){
				subArray[i] = msg[i];
			}
			MsgByte.Operation = subArray[0];
			MsgByte.val1 = subArray[1];
			MsgByte.val2 = subArray[2];
			MsgByte.val3 = subArray[3];
            MsgByte.val4 = subArray[4];
            MsgByte.heatmap = new byte[192];
			Array.Copy (subArray, 5, MsgByte.heatmap, 0, 192);
			string text = BitConverter.ToString(subArray);
			string msgtext =string.Join("",text.Split('-'));

			return msgtext;
		}

		/// <summary>
		/// Cast a movement to a given Byte array.
		/// </summary>
		/// <returns>The movement.</returns>
		public static HandMovement.Movement GetMovement(ByteCast msg) 
		{
            //The combination of Operation and val1 give the movement
			try
			{
                //I guess this should be an && condition. Otherwise this will always be true. (It was || before)
				if (msg.Operation != 0x01 && msg.Operation != 0x02 && msg.Operation != 0x74)
					return HandMovement.Movement.Error;

				switch (msg.val1){
				case 0x0:
					return HandMovement.Movement.Rest;
				case 0x07:
					if (msg.val2 == 0x01)
						return HandMovement.Movement.Extend;
					else
						return HandMovement.Movement.Flex;
				case 0x08:
					if (msg.val2 == 0x01)
						return HandMovement.Movement.Supination;
					else
						return HandMovement.Movement.Pronation;
				case 0x09:
					if (msg.val2 == 0x01)
						return HandMovement.Movement.Open;
					else
						return HandMovement.Movement.Close;
				case 0x0A:
					if (msg.val2 == 0x01)
						return HandMovement.Movement.Index;
					else
						return HandMovement.Movement.Error;//No animation
				case 0x0C:
					if (msg.val2 == 0x01)
						return HandMovement.Movement.Pincer;
					else
						return HandMovement.Movement.Error;//No animation
                case 0x0D:
                    if (msg.val2 == 0x01)
                        return HandMovement.Movement.Key;
                    else
                        return HandMovement.Movement.Error;
                    case 0x0F:
                        if (msg.val2 == 0x01)
                            return HandMovement.Movement.Flex;
                        else
                            return HandMovement.Movement.Extend;
                    default:
					    return HandMovement.Movement.Error;
					
				}
			}
			catch
			{
				return HandMovement.Movement.Error;
			}
		}

		/// <summary>
		/// Sends the ack.
		/// </summary>
		/// <param name="ack">Ack.</param>
		public void SendAck(byte ack)
		{
			WaitForAck = false;
			AckByte = ack;
		}
	}
}